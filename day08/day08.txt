----------------------------------------------------------------------

    실행컨텍스트

    "this"
    "스코프"
    "컨텍스트"
    "클로저"

----------------------------------------------------------------------


    자바스크립트의 실행컨텍스트
    : 자바스크립트가 실행되고 있는 환경을 정의한 것!!
    여기서 환경이란 : this,변수,상수,함수,객체등.. 코드 실행에 필요한 기반

    스코프: 구역 => 실행 컨텍스트로 구현하고자하는 최종 목표
    (변수,상수와 같은 환경들의 영역을 정의하고 구분짓는다!)

    스코프체인: 참조하려고 하는 값이 해당 컨텍스트에 존재하지 않으면 바로 상위
    의 스코프의 컨텍스트에서 값을 참조

----------------------------------------------------------------------

    실행컨텍스트의 종류
    
    중요한건 1,2번
    1. Global Execution Context(전역 실행 컨텍스트)
        처음으로 자바스크립트 코드가 실행될 때 생성되는 컨텍스트
        이 컨텍스트에서는 전역으로 관리되는 값을 관리!

    2. Function Execution Context(함수 실행 컨텍스트)
        각 함수가 실행(선언x 실행o)될 때 마다 생성되는 컨텍스트



    3. 그 외(Eval Execution,Modul Execution)
    
----------------------------------------------------------------------

    콜스택

    큐 --? [First In First Out]
    스택 --? [LIFO]의 특성을 가진 자료구조

    흐름
    1. 비어있는 컨텍스트
    2. 전역 컨텍스트 생성, 전역 스코프에 변수,함수가 평가
    3. 다른 함수가 실행되면서 함수 컨텍스트 생성(이때 함수 컨텍스트 평가!)
    4. 함수 안에서 또 다른 함수 (3) 실행
    5. 실행이 다 되면 컨텍스트 삭제!
    6. 모든 실행컨텍스트가 종료되면 컨텍스트 스택에서 제거

----------------------------------------------------------------------


    1. 평가
        실행 컨텍스트를 생성한 뒤 변수 함수 선언문들을 파악하여 현재 스코프(구역)에서
        사용이 가능한 변수,함수,식별자 등을 컨텍스트에 등록

        "호이스팅"이라는 것은 사실상 자바스크립트 언어 자체에서 존재하니 않는 말!
        다만 평가 과정에서 식별자에 의해 값이 할당되기 전에 선언이 먼저 기록되기
        때문에 개발자들 사이에서 호이스팅이라고 이름을 붙인 것 뿐

    2. 실행
        선언문을 제외한 호출, 런타임 , 실행과정에서 소스코드에 필요한 정보, 즉
        변수나 함수의 참조를 실행 컨텍스트에 등록된 것에부터 찾고 실행 과정에서
        변수의 값이 변경되면 재등록

----------------------------------------------------------------------


    실행컨텍스트 내부

    실행컨텍스트는 객체처럼 여러가지의 프로퍼티를 갖고 있음
    대표적으로 LexicalEnviroment가 있음!

    렉시컬 환경은 스코프를 관리, 이 안에서 변수, 함수값들이 저장!
    
    렉시컬 환경은 크게 두가지 영역으로 나뉨!

    Enviroment Record:
        식별자를 등록하고 관리하는 역할
    OuterLexicalEnviromentReference : 
        상위 스코프를 참조,이를 통해 상위 스코프 영역에 있는 변수들을 사용 가능!


    1. 식별자 생성
    2. this binding
    3. 참조할 외부 컨텍스트 결정
    4. 실행 과정에서 혹은 평과과정에서 생성된 정보들을 기반으로 값을 변경 -> 재등록

    let a = 5;
    a = 6; // a를 *초기화

----------------------------------------------------------------------


    * this
        "누가 나를 불렀나"
        즉 this의 값은 선언이 아닌 호출(누가 볼렀느냐)에 따라 달라질 수 밖에 없음
        => this 해당 매서드를 호출한 객체로 바인딩

    전역 함수 호출시 해당 함수의 this는 window가 된다!
    함수의 주인은 window
    
    this는 기본적으로는 window지만,
    use strict; 에서는 undefined => 디폴트 바인딩을 진행하지 않음!


    객체나 메소드,bind call, apply,new 일 때
    그리고 이벤트리스너나, 라이브러리에 의해
    this는 유동적으로 변경된다!

----------------------------------------------------------------------

    전역 실행 컨텍스트

    자바스크립트 코드가 실행되면서 먼저 전역 객체가 생성
    전역 객체에는 자바스크립트에서 기본적으로 포함되어있는 빌트인 객체, 함수, 객체
    를 포함한다!

    JS에 기본적으로 있는 빌트인 객체 = "console.log()"

    이러한 전역 객체 평가되면서 전역 실행 컨텍스트가 실행
    
    전역 실행 컨텍스트 두가지의 프로퍼티를 가지고 있음

    decleartive Enviroment Record
    : let 과 const로 선언한 변수들을 따로 관리
    여기에서 저장된 식별자들은 선언과 초기화가 분리되어 실행
    따라서 var로 선언한 변수와 함수선언과는 다르게 초기화전 까지는 접근 불가능(참조 에러)

    Object Enviroment Record
    : 그 외 영역을 관리(표준 빌트인 객체, 전역 함수 , var...)

    빌트인 객체:ECMAScript(es)에 정의된 기본 객체
    (실행컨텍스트와 상관없이 사용가능 (Math,Date....))

----------------------------------------------------------------------


    LexicalEnviroment(변수,식별자 저장소)와 실행컨텍스트는 별도로 관리
    LexicalEnviroment에서 참조되는 객체가 있다면 실행컨텍스트는 삭제되도
    LexicalEnviroment는 삭제되지 않습니다.

    LexicalEnviroment가 삭제되는 것은 참조 카운트가 0이 되었을 때
    이러한 원리에 의해 클로저를 구현할 수 있음!


----------------------------------------------------------------------

    클로저

        클로저는 자바스크립트만의 개념은 아님!
        함수를 일급객체(함수를 선언하고 컴파일[번역] 및 런타임[실행] 할 수 있는 언어)
        로 사용하는 모든 언어에서 사용되는 특성

        "클로저는 자신이 생성될 때의 환경을 기억하고, 그를 사용하는 함수이다"

        ex)

        function addNumFunction(num){
            const toAdd = num;

            return function(number){
                return number + toAdd
            }
        }

        const add5 = addNumFunction(5); // function

        add5(3) // 8
        add5(8) // 13

        클로즈 = 닫혀있다(범위가 정해짐{범위 안 toAdd를 사용가능하다!})
----------------------------------------------------------------------
    
    *클로저 사용 예시

    1. 상태은닉 ... 자바 private 와 비슷
    2. 상태공유
        const makeStudent =(function makeClass(teacher){
            return function(name){
                return{
                    name:name
                    getTeacher: () => teacher,
                    setTeacher: name =>{}
                        teacher = name
                }
            }
        }("기준")

    //실행 컨텍스트가 종료되어도 상태를 공유!

    const 철수 = makeStudent("철수")
    철수.getTeacher = 기준
    철수.setTeacher = 용성
    철수.getTeacher = 용성



    3. 상태기억


    "4. 메모이제이션(캐시) - 보류"

        값을 저장해두었다가 사용하는 것
        값이 바뀌지 않으면 저장해둔 값을 사용!

        ex)
        1(매개변수,input) => (연산) => 결과값 5
        2..3..4..

        1 => 연산(x) => 결과값 5


