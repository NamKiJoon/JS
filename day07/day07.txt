
------------------------------------------------------------------

    동기, 비동기

        "자바스크립트는 비동기 프로그래밍 언어다"

        동기 - 실시간? 동시에 일어나는 것? 
        비동기 - 비실시간? 동시에일어나지 않는 것?

        쓰레드 === 일꾼

        자바스크립트는 싱글쓰레드(일꾼이 하나) < --- > 멀티쓰레드(자바, GO)


**********************
        동기적인 흐름
            => 너는 나랑 동기야 (같이 간다)
            - 동기는 요청을 보낸 후 결과를 받아야만 다음 동작이 이루어지는 것

        비동기적인 흐름
            => 너는 나랑 동기가 아니야? 너는 너 할일 해 나는 내 할일 할게
              효율성을 위해 비동기는 요청을 보낸 후 결과를 받지 않아도
              다음 동작이 이루어지는 것
**********************


   -----------------------------------------------------------------

        '싱글 쓰레드, 멀티 쓰레드, 비동기'
        '이벤트 루프', 이벤트 큐(태스크 큐)'

        => 비동기가 무엇이냐?
        자바스크립트는 멀티 스레드가 아닌 싱글 스레드이기 때문에 한번에 한가지
        일 밖에 처리할 수 있음

        따라서, 시간이 소요되는 작업을 할 때는 해당 작업을 진행한 후 실행을 해야
        하는데 이러한 작업들은 비동기를 통해 효율적으로 운용할 수 있습니다

        비동기는 자바스크립트가 실행될 때 이벤트 루프를 통해 실행되며
        비동기 처리가 끝난 후 실행되어야 할 함수들은 이벤트큐에 저장해두었다가
        비동기가 끝난 후 차례대로 실행한다

        큐는 FIFO (First in , First out)

    ----------------------------------------------------------------

    백엔드에서 게시글 상세목록 조회 -> 게시글 정보 백엔드가 전달
    -> 게시글 정보를 받아오기 전에 해당 게시글의 정보를 사용한하는 로직이 실행된다면

    따라서 비동기 현상이 끝이나고 실행할 함수들을 이벤트 큐에 저장된 함수를 실행

    ----------------------------------------------------------------

    setTimeout, setInterval

    setTimeout
        : 넘겨준 함수를 해당 밀리초만큼 최소 시간을 보장 호출

        ex)
        setTimeout(()=> console.log("test"), 30000)
                                            (1000 = 1초)

        ex)
        let a = 5; ---> (1)
        setTimeout(()=> { a=10 console.log(a)}, 30000)) ----(3)
        console.log(a); // 5

    clearTimeout
        : setTimeout에 등록된 이벤트를 취소


    setInterval
        : 넘겨준 함수를 최소 해당 밀리초만큼 보장한 후 매번 호출

        ex)
        let a = 5;
        setInterval(()=>console.log(a), 5000) // 5....

        // 어떠한 버튼클릭 시 실행시킬 함수

        function stopInterver(){
            clearInterval()
        }

    clearInterval()
        : setInterval에 등록된 이벤트를 취소

    --------------------------------------------------------------------
        
    콜백함수 (callback function)
        : 부르고 되돌리기?, 다시 호출?

    매개변수로 함수를 전달받아서, 함수 내부에서 그 함수를 실행하는 경우
    
    ex)
        setTimeout( () => {} , 3000)
        
        const callback = (number, callback) => {
            number = numbr + 1;
            console.log(number);
            callback();
        }


**********************
    
    콜백 지옥(callback hell)
        js는 비동기를 마주하는 상황이 빈번하게 일어남
        
        백엔드에서 결과 값을 받아오기 전에 어떠한 로직을 실행하게되면
        에러 발생

        비동기로직을 동기적으로 처리할 필요가 생김
        이러한 동기적 처리를 위해 과거 많이 사용하던 로직이 콜백 함수

        그러나, 이런 콜백함수가 중첩되어 함수의 길이가 깊어지고(계단식)
        가독성이 떨어진다.

**********************
    --------------------------------------------------------------------

    promise (약속)

        비동기 통신 처리를 위하여 악명 높은 콜백지옥을 탈출시켰다는 점에서
        굉장히 높은 평가를 받고 있음

        promise는 대기상태(pending), 성공상태(resolve), 실패상태(reject)

        promise를 선언하는 순간.. 대기 상태에서 실행되어있지만,
        나중에 어떠한 조건을 만족했을 때 결과값을 받는 객체

        promise는 promise 타입의 객체 return(반환)
        객체 안의 then(성공) catch(실패)

        단, promise 또한 callback 함수에 기반을 두고 있다는 점에서
        한계가 존재함!

        따라서 자바스크립트에서는 이러한 promise의 한계점을 해결하기 위해서
        async await을 도입 [=async , await , promise]

    --------------------------------------------------------------------

    async await

        콜백에 기반을 두고있는 promise는 then , catch의 반복으로 코드가
        길어지는 현상이 생긴다는것은 다를것 없다!

        따라서 이러한 promise의 한계점을 해결하기 위해 등장

        async:
            async가 사용된 함수를 promise형태로 만들어주며 하위에 await이란 객체가 존재함!

        await:
            await 앞의 함수가 실행될 때까지 promise를 잠시 대기 시켜놓는다!
     
    --------------------------------------------------------------------


        백엔드 게시물 정보 요청
        시간이 지난 후 *비동기* 프론트엔드에 데이터를 전달
        
        프론트엔드에서 해당 데이터를 써먹으려고 봤더니
        그냥 일반적으로 실행하게 되면
        동기 흐름으로 처리되기 때문에 해당 데이터를 받기 전에 사용되므로
        사용이 불가한 상태에서

        즉 이러한 문제점을 해결하기 위해서
        비동기처리(콜백함수, promise,async/await)

        콜백함수는 비동기함수가 끝나면 매개변수로 전달된 콜백함수가 실행되는 형태
        또한 그 이후에 실행되는 함수들도 모두 콜백으로 전달

        promise는 콜백으로 전달하지 않고, .then이라는 로직으로 비동기가 실행 후
        실행해야할 함수를 실행

        async await
        then도 콜백도 필요없이 await을 통해 해당 비동기를 기다렸다가
        비동기 로직 이후 실행될 함수들을 동기적으로 작성해도 실행

    --------------------------------------------------------------------

        promise.ALL()
        자바스크립트 실행 컨텍스트, 클로저,베너이동, 마우스이벤트

    --------------------------------------------------------------------